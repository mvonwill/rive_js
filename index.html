<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rive + Mic Visualizer Overlay + Clock</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <style>
    @font-face {
      font-family: 'SansNormal';
      src: url('https://mvonwill.github.io/rive_js/fonts/sansnormtrial-160bold-webfont.woff2') format('woff2'),
           url('https://mvonwill.github.io/rive_js/fonts/sansnormtrial-160bold-webfont.woff') format('woff');
      font-weight: bold;
      font-style: normal;
      font-display: swap;
    }
    
    html, body {
      margin: 0; height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      font-family: 'SansNormal', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', 'Segoe UI', system-ui, sans-serif;
    }
    #animation-container {
      position: relative;
      width: 650px;
      height: 823px;
      user-select: none;
    }
    #rive-canvas {
      position: absolute;
      top: 0; left: 0;
      width: 650px; height: 823px;
      cursor: pointer;
      z-index: 0;
    }
    #waveCanvas {
      position: absolute;
      top: 260px;
      left: 107px;
      width: 436px;
      height: 823px;
      z-index: 2;
      pointer-events: none;
      background: transparent;
    }
    #clock-container {
      position: absolute;
      top: 32px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 3;
      pointer-events: none;
      text-align: center;
    }
    #digital-time {
      font-family: 'SansNormal', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', 'Segoe UI', system-ui, sans-serif;
      font-size: 23px;
      font-weight: bold;
      color: #4E4E4E;
      letter-spacing: 0.05em;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      font-feature-settings: "tnum" 1;
      font-variant-numeric: tabular-nums;
      line-height: 1.1;
    }
    #digital-time .colon {
      position: relative;
      top: -0.05em;
      margin-left: 0.03em;
      margin-right: 0;
      letter-spacing: 0;
    }
    canvas {
      image-rendering: auto;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .font-loading #digital-time {
      opacity: 0.7;
    }
    .font-loaded #digital-time {
      opacity: 1;
      transition: opacity 0.3s ease;
    }
  </style>
  <script src="https://unpkg.com/@rive-app/webgl2"></script>
</head>
<body class="font-loading">

  <!-- Dynamic background detection -->
  <script>
    if (window.self !== window.top) {
      // Inside iframe → Transparent background
      document.body.style.backgroundColor = "transparent";
    } else {
      // Standalone browser → Grey background
      document.body.style.backgroundColor = "#343434";
    }
  </script>

  <div id="animation-container">
    <canvas id="rive-canvas"></canvas>
    <canvas id="waveCanvas" width="650" height="823"></canvas>
    
    <div id="clock-container">
      <div id="digital-time">--<span class="colon">:</span>--</div>
    </div>
  </div>

  <!-- Your existing JavaScript remains unchanged below -->
  <script>
    // Font loading detection
    if ('fonts' in document) {
      document.fonts.ready.then(function() {
        document.body.classList.remove('font-loading');
        document.body.classList.add('font-loaded');
        console.log('SansNormal font loaded successfully');
      });
      setTimeout(function() {
        if (document.body.classList.contains('font-loading')) {
          document.body.classList.remove('font-loading');
          document.body.classList.add('font-loaded');
          console.log('Font loading timeout - proceeding with fallbacks');
        }
      }, 3000);
    } else {
      document.body.classList.remove('font-loading');
      document.body.classList.add('font-loaded');
    }

    function updateClock() {
      const now = new Date();
      const hours = now.getHours().toString().padStart(2, '0');
      const minutes = now.getMinutes().toString().padStart(2, '0');
      const timeString = `${hours}<span class="colon">:</span>${minutes}`;
      document.getElementById('digital-time').innerHTML = timeString;
    }
    updateClock();
    setInterval(updateClock, 1000);

    const riveCanvas = document.getElementById('rive-canvas');
    const riveScale = 2;
    riveCanvas.width = 650 * riveScale;
    riveCanvas.height = 823 * riveScale;
    riveCanvas.style.width = '650px';
    riveCanvas.style.height = '823px';

    let r;
    try {
      r = new rive.Rive({
        src: './assets/biometric_scan_JS.riv',
        canvas: riveCanvas,
        autoplay: true,
        artboard: 'MAIN WIP',
        stateMachines: 'State Machine 1',
        fit: rive.Fit.contain,
        antialias: true,
        onLoad() {
          console.log('Rive animation loaded successfully');
          r.resizeDrawingSurfaceToCanvas();
        },
        onLoadError(error) {
          console.error('Failed to load Rive file:', error);
          riveCanvas.style.display = 'none';
        }
      });
      r.on(rive.EventType.RiveEvent, onRiveEventReceived);
    } catch (error) {
      console.error('Error initializing Rive:', error);
      riveCanvas.style.display = 'none';
    }

    let eventCount = 0;
    let isAnimationPlaying = false;

    function onRiveEventReceived(riveEvent) {
      eventCount++;
      const eventName = riveEvent.data?.name || riveEvent.name;
      if (eventName === 'show_mic') {
        visualizerVisible = true;
        isAnimationPlaying = true;
      } else if (eventName === 'hide_mic') {
        visualizerVisible = false;
        isAnimationPlaying = false;
      }
    }

    window.addEventListener('resize', () => {
      if (r) r.resizeDrawingSurfaceToCanvas();
    });

    const canvas = document.getElementById('waveCanvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    const W = canvas.width, H = canvas.height;

    let audioCtx, analyser, dataArray, source, stream;
    let idlePhase = 0, micEnabled = false, visualizerVisible = false, visualizerOpacity = 0;
    const barCount = 78, maxBarWidth = 8, visualWidth = 650;
    const spacing = visualWidth / barCount;
    const xOffset = 0, verticalOffset = 0;
    let currentHeights = new Array(barCount).fill(H * 0.2);
    const volumeThreshold = 15;
    const amplitudeScale = 0.65 * 0.8 * 0.65 * 0.4;

    function lerp(a, b, t) { return a + (b - a) * t; }
    function getAverageVolume(data) { return data.reduce((a, b) => a + b) / data.length; }

    function setGlowStyle() {
      ctx.shadowColor = '#3BBBE4';
      ctx.shadowBlur = 6;
    }
    function clearGlowStyle() {
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
    }

    function drawIdleRow() {
      ctx.fillStyle = '#3BBBE4';
      setGlowStyle();
      idlePhase += 0.065;
      for(let i = 0; i < barCount; i++) {
        const x = xOffset + visualWidth - (i + 1) * spacing + (spacing - maxBarWidth) / 2 + maxBarWidth / 2 - 2;
        const sineValue = (Math.sin(idlePhase + i * 0.3) + 1) / 2;
        const size = lerp(2, 6, sineValue);
        const y = (H / 2 - size / 2) + verticalOffset;
        ctx.fillRect(x, y, size, size);
      }
      clearGlowStyle();
    }

    function getCenterOutMappedHeights(data) {
      const heights = new Array(barCount).fill(H * 0.2);
      const center = Math.floor(barCount / 2);
      for (let i = 0; i < barCount / 2; i++) {
        const leftValue = data[Math.min(data.length - 1, i)];
        const rightValue = data[Math.min(data.length - 1, i + 10)];
        const leftHeight = (leftValue / 255) * H * 0.6 * amplitudeScale;
        const rightHeight = (rightValue / 255) * H * 0.6 * amplitudeScale;
        heights[center - 1 - i] = leftHeight;
        heights[center + i] = rightHeight;
      }
      return heights;
    }

    function draw() {
      requestAnimationFrame(draw);
      ctx.clearRect(0, 0, W, H);
      visualizerOpacity = visualizerVisible ? Math.min(1, visualizerOpacity + 0.05) : Math.max(0, visualizerOpacity - 0.05);
      if (visualizerOpacity <= 0) return;
      ctx.globalAlpha = visualizerOpacity;

      if (!analyser || !micEnabled) {
        drawIdleRow();
        ctx.globalAlpha = 1;
        return;
      }

      analyser.getByteFrequencyData(dataArray);
      const avgVol = getAverageVolume(dataArray);

      if (avgVol < volumeThreshold) {
        drawIdleRow();
        currentHeights = currentHeights.map(h => lerp(h, H * 0.2, 0.05));
      } else {
        const liveHeights = getCenterOutMappedHeights(dataArray).map((h, i) => lerp(currentHeights[i], h, 0.2));
        currentHeights = liveHeights;
        ctx.strokeStyle = '#3BBBE4';
        ctx.fillStyle = '#3BBBE4';
        setGlowStyle();
        liveHeights.forEach((height, i) => {
          const x = xOffset + i * spacing + (spacing - maxBarWidth) / 2;
          const yTop = ((H - height) / 2) + verticalOffset;
          const yBottom = yTop + height;
          ctx.beginPath();
          ctx.moveTo(x + maxBarWidth / 2, yTop);
          ctx.lineTo(x + maxBarWidth / 2, yBottom);
          ctx.stroke();
          ctx.fillRect(x + maxBarWidth / 2 - 2, yTop - 2, 4, 4);
          ctx.fillRect(x + maxBarWidth / 2 - 2, yBottom - 2, 4, 4);
        });
        clearGlowStyle();
      }
      ctx.globalAlpha = 1;
    }

    draw();

    function enableAudio() {
      if (micEnabled) return;
      navigator.mediaDevices.getUserMedia({ audio: true }).then(mediaStream => {
        stream = mediaStream;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 128;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        source = audioCtx.createMediaStreamSource(stream);
        source.connect(analyser);
        micEnabled = true;
      }).catch(err => {
        console.error('Mic error:', err);
        alert('Mic access is required for the visualizer.');
      });
    }

    document.addEventListener('click', function() {
      if (!micEnabled) enableAudio();
    }, { once: true });

    riveCanvas.addEventListener('click', function() {
      if (!isAnimationPlaying) {
        isAnimationPlaying = true;
      }
    });
  </script>
</body>
</html>
